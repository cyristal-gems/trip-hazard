<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <title>Trip Hazard: The Game</title>
  <style>
    :root{
      --ink:#e8ecf5; --bg:#0b1220; --panel:#0f172a; --muted:#9aa4b2;
      --accent:#ff3b7d; --lane:#ffd166; --ground:#0a0f1a; --stripe:#0f1a2e;
      --sky1:#0e1a2d; --sky2:#0b1220;
      --obstacle:#7cf6ff; --obstacle-glow:#89f7ff; --obstacle-outline:#072e38;
    }
    html,body{height:100%; margin:0; background:var(--bg); color:var(--ink); font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;}
    .page{max-width:1100px; margin:0 auto; padding:0 12px 24px}
    .header{max-width:900px; margin:20px auto 18px; text-align:center;}
    .header h1{margin:0 0 14px; font-size:clamp(26px,4.6vw,36px); font-weight:900}
    .header p{margin:0 auto; color:var(--muted); font-size:16px; line-height:1.5}
    .stage{position:relative; width:100%; aspect-ratio:16/10; max-height:66vh; border-radius:18px; box-shadow:0 20px 40px rgba(0,0,0,.45); overflow:hidden}
    #game{background:linear-gradient(var(--sky1),var(--sky2) 60%); width:100%; height:100%; display:block}
    .ui-top-right{position:absolute; right:12px; top:12px; display:flex; align-items:center; gap:8px; z-index:3}
    .badge{background:var(--panel); color:var(--ink); padding:8px 12px; border-radius:999px; font-weight:800; box-shadow:0 6px 20px rgba(0,0,0,.35); font-size:14px}
    .btn{border:0; background:var(--panel); color:var(--ink); font-weight:900; padding:8px 10px; border-radius:10px; cursor:pointer; box-shadow:0 6px 20px rgba(0,0,0,.35)}
    .ui-start{position:absolute; left:50%; bottom:16px; transform:translateX(-50%); z-index:3}
    .ui-start .start{border:0; background:var(--accent); color:#fff; font-weight:900; padding:12px 16px; border-radius:12px; cursor:pointer; box-shadow:0 10px 30px rgba(0,0,0,.45)}
    .visually-hidden{position:absolute !important; height:1px; width:1px; overflow:hidden; clip:rect(1px,1px,1px,1px); white-space:nowrap}
    .controls-overlay{
      position:absolute; left:12px; top:50%; transform:translateY(-50%);
      background:rgba(15,23,42,.92); border:1px solid rgba(255,255,255,.06);
      padding:10px 12px; border-radius:14px; box-shadow:0 10px 30px rgba(0,0,0,.4);
      max-width:220px; z-index:2; backdrop-filter: blur(2px);
    }
    .controls-overlay h3{margin:0 0 6px; font-size:12px; text-transform:uppercase; letter-spacing:.35px; opacity:.9}
    .controls-overlay ul{margin:0 0 0 16px; padding:0; font-size:13px; line-height:1.4}
    .controls-overlay li{margin:4px 0}
    @media (max-width: 540px){
      .stage{aspect-ratio:auto; height:85vh; max-height:none;}
      .ui-top-right{right:8px; top:8px; gap:6px;}
      .badge{padding:6px 8px; font-size:12px;}
      .btn{padding:6px 8px; border-radius:8px;}
      .controls-overlay{left:8px; bottom:10px; top:auto; transform:none; max-width:200px; padding:8px 10px;}
      .controls-overlay ul{font-size:12px;}
    }
  
    /* Prevent overlays from blocking gameplay; keep buttons clickable */
    .ui-top-right, .controls-overlay, .ui-start { pointer-events: none; }
    .ui-top-right .btn, .ui-start .start { pointer-events: auto; }

</style>
</head>
<body>
  <div class="header">
    <h1>Trip Hazard: The Game</h1>
    <p>A moody sprint: pixel duck, prickly bushes, pesky birds—easy start, tough finish. Built with HTML, CSS, JavaScript, and Canvas.</p>
  </div>

  <div class="page">
    <div class="stage" id="stage">
      <canvas id="game"></canvas>

      <div class="ui-top-right">
        <span class="badge" id="best">HI 00000</span>
        <span class="badge" id="score">00000</span>
        <button class="btn" id="btnPause" title="P">⏸</button>
        <button class="btn" id="btnRestart" title="R">↺</button>
      </div>

      <div class="ui-start" id="uiStart">
        <button class="start" id="btnStart">▶ Start Run</button>
      </div>

      <div class="controls-overlay" aria-label="Game controls">
        <h3>Controls</h3>
        <ul>
          <li><strong>Desktop:</strong> Space = Jump, L = Duck</li>
          <li><strong>Tablet:</strong> Tap = Jump; Hold Down = Duck</li>
        </ul>
      </div>

      <div class="visually-hidden" id="sr">Ready</div>
    </div>
  </div>

  <!-- JS (same as before, unchanged) -->
  
<script>
(function(){
  // ===== DOM =====
  const canvas=document.getElementById('game'); const ctx=canvas.getContext('2d',{alpha:false});
  const stage=document.getElementById('stage');
  const uiStart=document.getElementById('uiStart');
  const btnStart=document.getElementById('btnStart');
  const btnPause=document.getElementById('btnPause');
  const btnRestart=document.getElementById('btnRestart');
  const elScore=document.getElementById('score');
  const elBest=document.getElementById('best');
  const sr=document.getElementById('sr');

  // ===== Helpers =====
  const DPR=Math.max(1,Math.min(2,window.devicePixelRatio||1));
  const S=(px)=>Math.floor(px*DPR);
  const rnd=(a,b)=>Math.random()*(b-a)+a;
  const pad5=(n)=>Math.floor(n).toString().padStart(5,'0');
  const collide=(a,b)=>!(a.x+a.w<b.x || a.x>b.x+b.w || a.y+a.h<b.y || a.y>b.y+b.h);

  // ===== Fit canvas =====
  function fit(){
    const r=stage.getBoundingClientRect();
    canvas.width=Math.floor(r.width*DPR);
    canvas.height=Math.floor(r.height*DPR);
    canvas.style.width=r.width+'px';
    canvas.style.height=r.height+'px';
  }
  if ('ResizeObserver' in window) new ResizeObserver(()=>fit()).observe(stage);
  window.addEventListener('resize', fit, {passive:true});
  fit();

  // ===== Config =====
  const GROUND_H=56, GRAVITY=0.00185;
  const START_SPEED=0.16, MAX_SPEED=0.46, ACCEL=0.000007;
  const SCORE_RATE=0.012, CHECKPOINT=100, BIRD_UNLOCK=220;
  // Bird spawning mode
  const BIRD_FIXED_TIMER=false;        const BIRD_SCORE_UNLOCK=500;
  // set to true to spawn birds on a fixed timer
  const BIRD_INTERVAL_MIN = 2600;       // ms (early game)
  const BIRD_INTERVAL_MAX = 4200;       // ms (early game)
  const BIRD_INTERVAL_MIN_FAST = 1500;  // ms (late game)
  const BIRD_INTERVAL_MAX_FAST = 2800;  // ms (late game)

  // ===== State =====
  const player={ x:90, y:0, w:42, h:46, vy:0, onGround:false, ducking:false };
  let last=0, running=false, paused=false, speed=START_SPEED;
  let obstacles=[], puffs=[];
  let spawnT=900;
  // bird timer state
  let birdTimer = 0;
  let nextBirdIn = 0; // ms until next bird
  let score=0, scoreAcc=0, best=+(localStorage.getItem('trip-hazard-best')||0);

  // ===== Init UI =====
  if (elBest) elBest.textContent='HI '+pad5(best);
  if (elScore) elScore.textContent='00000';
  if (sr) sr.textContent='Ready';

  const floorY=()=>canvas.height - S(GROUND_H) - S(player.h);

  // ===== Controls =====
  function start(){ reset(); }
  function jump(){ if(!running||paused) return; if(player.onGround && !player.ducking){ player.vy = -0.72 * (canvas.height/600); player.onGround=false; } }
  function setDuck(on){ player.ducking = on && player.onGround; }

  // Keyboard
  window.addEventListener('keydown', e=>{
    if (uiStart && !uiStart.hidden && (e.code==='Space'||e.code==='ArrowUp')) { e.preventDefault(); start(); return; }
    if (e.code==='Space' || e.code==='ArrowUp'){ e.preventDefault(); jump(); }
    if (e.code==='KeyL'){ e.preventDefault(); setDuck(true); }
    if (e.code==='KeyP' && btnPause) { e.preventDefault(); pauseToggle(); }
    if (e.code==='KeyR' && btnRestart) { e.preventDefault(); restart(); }
  });
  window.addEventListener('keyup', e=>{ if (e.code==='KeyL'){ e.preventDefault(); setDuck(false); } });

  // Tablet: Tap = Jump; Hold Down = Duck
  let holdTimer=null, duckHeld=false;
  stage.addEventListener('pointerdown', (e)=>{
    if (uiStart && !uiStart.hidden) { e.preventDefault(); start(); return; }
    if (e.target===stage || e.target===canvas){
      duckHeld=false;
      holdTimer=setTimeout(()=>{ setDuck(true); duckHeld=true; }, 140);
    }
  });
  stage.addEventListener('pointerup', (e)=>{
    if (e.target===stage || e.target===canvas){
      if(duckHeld){ setDuck(false); duckHeld=false; }
      else { clearTimeout(holdTimer); jump(); }
    }
  });
  stage.addEventListener('pointercancel', ()=>{ clearTimeout(holdTimer); setDuck(false); duckHeld=false; });

  if (btnStart) btnStart.addEventListener('click', (e)=>{ e.preventDefault(); start(); });
  if (btnPause) btnPause.addEventListener('click', (e)=>{ e.preventDefault(); pauseToggle(); });
  if (btnRestart) btnRestart.addEventListener('click', (e)=>{ e.preventDefault(); restart(); });

  function pauseToggle(){ if(!running) return; paused=!paused; if(btnPause) btnPause.textContent = paused ? '▶' : '⏸'; if(!paused){ last=performance.now(); requestAnimationFrame(loop); } }
  function restart(){ running=false; if(uiStart) uiStart.hidden=false; if(btnPause) btnPause.textContent='⏸'; if (sr) sr.textContent='Ready'; }

  // ===== Obstacles =====
  function spawnObstacle(){
    const diff = 1 + Math.min(1.4, score / 500);
    const gap = rnd(980, 1500) / Math.sqrt(diff);

    let kind='bush';
    if (score >= BIRD_SCORE_UNLOCK){
      // probability rises with difficulty (like Chrome's increasing challenge)
      const diff = 1 + Math.min(1.4, score / 500);
      const birdChance = Math.min(0.55, 0.18 + (diff-1) * 0.35); // ~18% at unlock -> up to 55%
      if (Math.random() < birdChance) kind='bird';
    }

    if (kind==='bush'){
      const size = rnd(28, 44) * (1 + (diff-1)*0.1);
      obstacles.push({ kind:'bush', x: canvas.width + S(10), y: canvas.height - S(GROUND_H) - S(size*0.9), w: S(size), h: S(size*0.9) });
    } else {
      const size = rnd(26, 34) * (1 - Math.min(0.2, (diff-1)*0.1));
      const baseTop = canvas.height - S(GROUND_H) - S(player.h); // player's standing head
      const birdH = S(size*0.8);
      const bottoms = [ baseTop + S(4), baseTop + S(8), baseTop + S(16) ];
      const bottom = bottoms[Math.floor(Math.random()*bottoms.length)];
      const y = bottom - birdH;
      obstacles.push({ kind:'bird', x: canvas.width + S(10), y, w: S(size), h: birdH, flap:0 });
    }
    spawnT = gap;
  }

  // ===== Drawing =====
  function drawBackground(){
    const gY=canvas.height-S(GROUND_H);
    const cs=getComputedStyle(document.documentElement);
    // Sky gradient
    const grd=ctx.createLinearGradient(0,0,0,gY);
    grd.addColorStop(0,cs.getPropertyValue('--sky1').trim()||'#0e1a2d');
    grd.addColorStop(1,cs.getPropertyValue('--sky2').trim()||'#0b1220');
    ctx.fillStyle=grd; ctx.fillRect(0,0,canvas.width,gY);
    // Stripes
    ctx.fillStyle=cs.getPropertyValue('--stripe').trim()||'#0f1a2e';
    const stripeH=S(6); const off=(performance.now()/6)%S(60);
    for(let y=S(40); y<gY; y+=S(60)) ctx.fillRect(0,y+off,canvas.width,stripeH);
    // Ground + lane
    ctx.fillStyle=cs.getPropertyValue('--ground').trim()||'#0a0f1a'; ctx.fillRect(0,gY,canvas.width,S(GROUND_H));
    ctx.fillStyle=cs.getPropertyValue('--lane').trim()||'#ffd166';
    const step=S(60); const roadOff=(performance.now()*speed*2)%(step*2);
    for(let x=-step*2+roadOff; x<canvas.width; x+=step*2) ctx.fillRect(x,gY+S(24), step, S(8));
  }

  function drawDuck(px,py){
    const unit = Math.max(2, S(2));
    ctx.save(); ctx.translate(px, py);
    const d = player.ducking;
    // body
    ctx.fillStyle='#f6e58d';
    const bodyW = d ? S(40) : S(30);
    const bodyH = d ? S(22) : S(26);
    const bodyX = d ? S(4) : S(8);
    const bodyY = d ? S(18) : S(10);
    ctx.fillRect(bodyX, bodyY, bodyW, bodyH);
    // head
    const headW = d ? S(18) : S(20);
    const headH = d ? S(16) : S(18);
    const headX = d ? S(10) : S(6);
    const headY = d ? S(6) : S(0);
    ctx.fillRect(headX, headY, headW, headH);
    // eye
    ctx.fillStyle='#1f2937'; ctx.fillRect(headX + unit*2, headY + unit*3, unit, unit);
    // bill
    ctx.fillStyle='#ffa94d'; ctx.fillRect(headX + headW, headY + unit*4, unit*2, unit);
    // wing
    ctx.fillStyle='#f1d36b'; ctx.fillRect(bodyX + unit*5, bodyY + unit*2, unit*6, unit*4);
    // feet when grounded
    if (player.onGround){ ctx.fillStyle='#ff922b'; ctx.fillRect(bodyX + unit*4, bodyY + bodyH, unit*3, unit); ctx.fillRect(bodyX + unit*10, bodyY + bodyH, unit*3, unit); }
    ctx.restore();
  }

  function drawBush(o){
    const x=Math.floor(o.x), y=Math.floor(o.y), w=o.w, h=o.h;
    ctx.save();
    ctx.fillStyle='#0b2e1f'; ctx.fillRect(x-2,y-2,w+4,h+4);
    ctx.fillStyle='#1e9e5a';
    const m = Math.max(4, Math.floor(h/4));
    for(let i=0;i<5;i++){ const bx = x + Math.floor((i/5)*w) + (i%2?2:0); const by = y + Math.floor((i%3)*m); ctx.fillRect(bx, by, Math.max(6, Math.floor(w/4)), Math.max(6, Math.floor(h/2))); }
    ctx.fillStyle='#167a45'; ctx.fillRect(x, y + Math.floor(h*0.6), w, Math.floor(h*0.4));
    ctx.restore();
  }

  function drawBird(o, dt){
    o.flap = (o.flap + dt*0.01) % 1;
    const frame = o.flap < 0.5 ? 0 : 1;
    const x = Math.floor(o.x), y = Math.floor(o.y), w = o.w, h = o.h;
    const unit = Math.max(2, S(2));
    ctx.save();
    ctx.fillStyle='#d1e4ff'; ctx.fillRect(x + unit*1, y + unit*2, w - unit*2, h - unit*3);
    ctx.fillRect(x, y, unit*4, unit*4);
    ctx.fillStyle='#0b1220'; ctx.fillRect(x + unit*1, y + unit*1, unit, unit);
    ctx.fillStyle='#ffa94d'; ctx.fillRect(x - unit*2, y + unit*2, unit*2, unit);
    ctx.fillStyle='#b8d7ff'; if (frame===0) ctx.fillRect(x + Math.floor(w/3), y + h - unit*2, unit*6, unit*2); else ctx.fillRect(x + Math.floor(w/3), y + unit, unit*6, unit*2);
    ctx.restore();
  }

  function drawPuffs(){ ctx.fillStyle='rgba(0,0,0,.2)'; for(const p of puffs){ ctx.beginPath(); ctx.arc(p.x,p.y,p.r,0,Math.PI*2); ctx.fill(); } }

  // ===== Loop =====
  function reset(){
    last=performance.now(); running=true; paused=false; speed=START_SPEED;
    obstacles.length=0; puffs.length=0; score=0; scoreAcc=0; spawnT=900;
    // reset bird timer
    birdTimer = 0;
    nextBirdIn = 0;
    player.vy=0; player.ducking=false; player.y=floorY(); player.onGround=true;
    if (elScore) elScore.textContent='00000'; if (elBest) elBest.textContent='HI '+pad5(best);
    if (uiStart) uiStart.hidden=true; if (sr) sr.textContent='Running';
    requestAnimationFrame(loop);
  }

  function update(dt){
    if(paused) return;
    // speed ramp
    speed = Math.min(MAX_SPEED, speed + ACCEL * dt);

    // score
    const prev = score;
    scoreAcc += dt * speed * (canvas.width/900) * SCORE_RATE;
    score = Math.floor(scoreAcc);
    if (score !== prev){
      if (elScore) elScore.textContent = pad5(score);
      if (score > best){ best = score; localStorage.setItem('trip-hazard-best', best); if (elBest) elBest.textContent='HI '+pad5(best); }
      if (score % CHECKPOINT === 0 && sr) sr.textContent='Checkpoint '+score;
    }

    // physics
    player.vy += GRAVITY * dt * (canvas.height/600);
    player.y += player.vy * dt * DPR;
    const fy = floorY();
    if (player.y >= fy){
      if(!player.onGround){ puffs.push({x:S(player.x+player.w/2), y:canvas.height - S(GROUND_H)-S(3), r:S(2), life:260}); }
      player.y = fy; player.vy = 0; player.onGround = true;
    } else {
      player.onGround=false;
    }

    // spawn + move obstacles
    spawnT -= dt; if (spawnT<=0) spawnObstacle();
    for (const o of obstacles){ o.x -= speed*dt*DPR*(canvas.width/900); }
    obstacles = obstacles.filter(o=>o.x + o.w > -4);

    
    // fixed-timer bird spawning (separate from obstacle cadence)
    if (BIRD_FIXED_TIMER && score >= BIRD_UNLOCK){
      // advance timer
      birdTimer += dt;
      // choose an interval that shrinks with difficulty (but bounded)
      const diff = 1 + Math.min(1.4, score / 500);
      const minI = BIRD_INTERVAL_MIN + (BIRD_INTERVAL_MIN_FAST - BIRD_INTERVAL_MIN) * Math.min(1, (diff-1)/1.4);
      const maxI = BIRD_INTERVAL_MAX + (BIRD_INTERVAL_MAX_FAST - BIRD_INTERVAL_MAX) * Math.min(1, (diff-1)/1.4);
      if (nextBirdIn <= 0) {
        nextBirdIn = Math.random() * (maxI - minI) + minI;
      }
      if (birdTimer >= nextBirdIn){
        birdTimer = 0;
        nextBirdIn = 0;
        // spawn a bird at one of three heights that always requires duck
        const size = Math.max(26, Math.min(34, 30 - (diff-1)*6));
        const baseTop = canvas.height - S(GROUND_H) - S(player.h); // player's standing head
        const birdH = S(size*0.8);
        const bottoms = [ baseTop + S(4), baseTop + S(8), baseTop + S(16) ];
        const bottom = bottoms[Math.floor(Math.random()*bottoms.length)];
        const y = bottom - birdH;
        obstacles.push({ kind:'bird', x: canvas.width + S(10), y, w: S(size), h: birdH, flap:0 });
      }
    }
// collisions (ducking hitbox)
    const duckOffset = player.ducking ? S(12) : 0;
    const ph = player.ducking ? S(player.h - 12) : S(player.h);
    const pr = { x:S(player.x), y:Math.floor(player.y)+duckOffset, w:S(player.w), h:ph };
    for(const o of obstacles){
      const box={x:Math.floor(o.x), y:Math.floor(o.y), w:o.w, h:o.h};
      if (collide(pr, box)){
        if (uiStart) uiStart.hidden=false; running=false; paused=false; if (sr) sr.textContent='Game over'; return;
      }
    }

    // puffs
    for(const p of puffs){ p.life -= dt; p.r += 0.06*dt/DPR; }
    puffs = puffs.filter(p=>p.life>0);
  }

  function render(dt){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    drawBackground();
    drawPuffs();
    for(const o of obstacles){ if (o.kind==='bush') drawBush(o); else drawBird(o, dt); }
    drawDuck(S(player.x), Math.floor(player.y));
  }

  function loop(t){ if(!running||paused) return; const dt=Math.min(34, t-last); last=t; update(dt); render(dt); requestAnimationFrame(loop); }

  // Show start overlay by default and allow starting from UI and keyboard
  if (uiStart) uiStart.hidden=false;
})();
</script>

</body>
</html>